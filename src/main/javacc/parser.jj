options {
   IGNORE_CASE = true;
   STATIC = false;
   SUPPORT_CLASS_VISIBILITY_PUBLIC = false;
}


PARSER_BEGIN(DefaultNameParser)
package com.realcomp.names;
import java.util.*;
import java.io.*;
import java.util.logging.Logger;
import java.util.logging.Level;

/**
 * This class is generated by javacc.
 * To make changes, see src/main/javacc/parser.jj
 */
final class DefaultNameParser implements NameParser{

    private static final Logger logger = Logger.getLogger(DefaultNameParser.class.getName());

    private SingleNameParsingContext ctx;
    private List<Name> names;  
    private String original;
    private int andCount;
    private boolean foundCareOf;
    private boolean foundCompany;
    private String previousLastName;
    private String potentialFirstName;
    
    public DefaultNameParser(boolean lastNameFirst) {
        this((Reader) new StringReader(""));        
        names = new ArrayList();
        ctx = new SingleNameParsingContext(lastNameFirst);
    }

    public Name parse(String text){
        Objects.requireNonNull(text);
        if (text.isEmpty()){
            throw new IllegalArgumentException("text is empty");
        }
        Name name = null;
        previousLastName = null;
        original = text;
        names.clear();
        potentialFirstName = null;
        andCount = 0;
        foundCareOf = false;
        foundCompany = false;
        ctx.reset();
        ReInit((Reader)(new StringReader(text)));
        try{
            start();
            name = next();
        }
        catch(ParseException ex){
            names.clear();
            logger.log(Level.FINE, "Problem parsing [" + text + "] : " + ex.getMessage());
        }

        if (name == null){
            name = new Name(original);
            name.setCompany(true);
            names.clear();
        }
        else if (name.isCompany() && !foundCareOf && !names.isEmpty()){
            name = new Name(original);
            name.setCompany(true);
            names.clear();
        }
        else if (andCount > 1 && foundCompany){
            //"B & G CHEMICAL & EQPT CO INC" vs "JOHN DOE & JANE SMITH & WALTER JONES"            
            name = new Name(original);
            name.setCompany(true);
            names.clear();
        }

        return name;
    }

    public List<Name> parseAll(String text){
        List<Name> names = new ArrayList();
        names.add(parse(text));
        while (hasNext()){
            names.add(next());
        }
        return names;
    }

    public boolean hasNext(){
        return !names.isEmpty();
    }

    public Name next(){
        return names.isEmpty() ? null : names.remove(0);
    }


    private void pushName(){
        if (ctx.hasContent()){
            if (names.size() == 1 && !ctx.isCareOf() && !ctx.isCompany() && !ctx.hasLastName()){
                Name spouse = names.get(0);
                if (!spouse.getLast().isEmpty()){
                    ctx.add(new ParsedToken(spouse.getLast(), TokenType.LAST));
                }
            }

            if (names.size() == 0 && ctx.getNumTokens() == 1 && !ctx.isCompany() && !ctx.isTrust()){
                ctx.setCompany(true);
            }

            Name name = ctx.build();
            if (name.isCompany() && !name.isCareOf() && names.size() == 1 && !names.get(0).isCompany()){
                names.clear();
                name = new Name(original);
                name.setCompany(true);
                ctx.setSkipRemaining(true);
            }
            else if (name.isCompany() && potentialFirstName != null && names.size() == 0){
                //handle "name & name inc"
                names.clear();
                name = new Name(original);
                name.setCompany(true);
                ctx.setSkipRemaining(true);
            }
            else if (!name.isCompany()){
                previousLastName = name.getLast();
                if (potentialFirstName != null){
                    //handle "john & jane doe"
                    if (ctx.isLastNameFirst()){
                        name = ProperNameBuilder.swapFirstAndLastName(name);
                        previousLastName = name.getLast();
                    }
                    
                    String s = potentialFirstName + " " + previousLastName;
                    Name previous = new Name(s.trim());
                    previous.setLast(previousLastName);
                    previous.setFirst(potentialFirstName);
                    names.add(previous);
                }   
            }           

            if (name.isCompany()){
                foundCompany = true;
            }
            names.add(name);
        }

        ctx.reset();   
    }

    private void and(String token){
        andCount++;
        //need to determine if this is the start of a new name, or continuation of a company name.    
        if (ctx.isCompany()){
            ctx.add(new ParsedToken(token, TokenType.COMPANY));
        }
        else if (ctx.getNumTokens() == 1 && !ctx.isCareOf()){
            //a single token encountered before an &
            // this is either some company name, or a name like "john & jane doe"
            potentialFirstName = ctx.build().toString();
            ctx.reset();
        }
        else if (token.length() > 1){
            //no delimiter after & (e.g., "Mike &Assoc")
            pushName();
            token = token.substring(1);
            if (CompanyNameTokens.contains(token)){
                ctx.add(new ParsedToken(token, TokenType.COMPANY));
            }
            else{
                ctx.add(new ParsedToken(token, TokenType.UNKNOWN));
            }
        }
        else{
            //ignore the "&"
            pushName();
            ctx.setLastNameFirst(false);
        }
    }

}
PARSER_END(DefaultNameParser)

void start() : {}  { (name() (careOf() name())? ) done() }

void done() : {} {<EOF> {
    pushName();
}}

void name() : {} { (token() | multiName() | prefix() | suffix() | comma() | company() | estate() | trust() | and() | web() | etux() | alsoKnownAs() )+ {
    pushName();
}}

void company() : {Token t;} { 
    t=<COMPANY> {ctx.add(new ParsedToken(t.image, TokenType.COMPANY));} | 
    t=<US_STATE> {ctx.add(new ParsedToken(t.image, TokenType.COMPANY));} | 
    t=<US_STATE_ABBV> {ctx.add(new ParsedToken(t.image, TokenType.COMPANY));}
}

void web() : {Token t;} { t=<WEB> {
    ctx.appendToPreviousToken(t.image);
}}

void suffix() : {Token t;} { t=<SUFFIX> {
    ctx.add(new ParsedToken(t.image, TokenType.SUFFIX));
}}

void prefix() : {Token t;} { t=<PREFIX> {
    ctx.add(new ParsedToken(t.image, TokenType.PREFIX));
}}

void estate() : {Token t;} { t=<ESTATE> {
    ctx.add(new ParsedToken(t.image, TokenType.ESTATE));
}}

void trust() : {Token t;} { 
    t=<TRUST> {ctx.add(new ParsedToken(t.image, TokenType.TRUST));} | 
    t=<SIMPLE_TRUST> {ctx.add(new ParsedToken(t.image, TokenType.TRUST));}
}

void comma() : {Token t;} { t=<COMMA> {
    ctx.comma();
}}

void and() : {Token t;} { t=<AND>  {
    if (ctx.isCareOf()){
        ctx.add(new ParsedToken(t.image, TokenType.COMPANY));
    }
    else{
        and(t.image);
    }
}}

void careOf() : {Token t;} { t=<CARE_OF>  {
    pushName();
    foundCareOf = true;
    ctx.setCareOf(true);
    ctx.setLastNameFirst(false);
    String s = t.image;
    if (s.startsWith("%") && s.length() > 1){
        s = s.substring(1);
        if (s.equals(previousLastName)){
            ctx.add(new ParsedToken(s, TokenType.LAST));
        }
        else{
            ctx.add(new ParsedToken(s, TokenType.UNKNOWN));
        }
    }
}}


void alsoKnownAs() : {Token t;} { t=<AKA> {
   ctx.setSkipRemaining(true);
}}

void etux() : {Token t;} { t=<ETUX> {
   ctx.setSkipRemaining(true);
}}

void multiName() : {Token t;} { t=<MULTI_NAME> {
    ctx.add(new ParsedToken(t.image, TokenType.LAST));
}}

void token() : {Token t;} { t=<_TOKEN> {
    if (CompanyNameTokens.contains(t.image)){
        ctx.add(new ParsedToken(t.image, TokenType.COMPANY));
    }
    else if (t.image.equals(previousLastName)){
        ctx.add(new ParsedToken(t.image, TokenType.LAST));
    }   
    else{
        ctx.add(new ParsedToken(t.image, TokenType.UNKNOWN));
    }
}}



SPECIAL_TOKEN :
{
  <PUNCT: [ "." ]>
}

SKIP : { <DELIMITERS: [" ", "\t", "\n", "\r"]> }
SKIP : { <TRUSTEE : "EXECUTOR" | ("CO" (["-"," "]))? "TRUSTE" ("E")? (" OF")?> }
TOKEN : { <ETUX : "ET" (" ")? ( "UX" | "AL" | "VIR" | "TU" | "TIV" )> }
TOKEN : { <TRUST : ("LIV" | "REV" | "IRR" | "RES" | "FAM" | "MAR" | "CO" | "SUC" )(["A"-"Z"])*(" TR")(("U")?"S"("T")?)? > }
TOKEN : { <SIMPLE_TRUST : "TRUST" > }
TOKEN : { <ESTATE: ("LIFE ")?"EST" ("ATE")? (" OF")?> }
TOKEN : { <COMMA: "," > }
TOKEN : { <AND: ("AND" | ["+", "&"](["A"-"Z"])*) > }
TOKEN : { <CARE_OF: ("C/O" | "%"(["A"-"Z"])* )> }
TOKEN : { <AKA: ("A"|"F"|"N")("KA") > }
TOKEN : { <WEB: (".COM" | ".NET" | ".EDU") >}
TOKEN : { <PREFIX: "DR" | "MR" | "MRS" | "MS" | "MISS" | "REV" | "HON" | "PROF" | "ATTY" | "PRES" | "GOV" | "COACH" | "OFC" | "GEN" | "COL" | "LT" | "CMDR" | "CAPT" | "MAJ" | "ADM" | "SGT" | "PVT" | "SEC" | "AMB" | "SEN" | "SUPT" | "MSGR" > }
TOKEN : { <SUFFIX: "JR" | "SR" | "II" | "III" | "IV" | "ESQ" | "PHD" | "MD" | "DMD" | "PA" > }
TOKEN : { <MULTI_NAME: "VAN" | "DE" | "LA" | "LAS" | "MC" | "MAC" | "EL" | "VON" | "LOS" | "LE" | "DEL" | "DER" > }

/* Single token company names are handled by the CompanyNameTokens class.  
   Some often encountered tokens are duplicated here for speed.  
   Multi-token company name identifiers are handled here. */
TOKEN : { <COMPANY: 
   (["A"-"Z"])*(["/","0"-"9","@"])+(["A"-"Z"])* |  
   (["A"-"Z"])+"'S" |
   "BUSINESS" | "COMPANY" |
   "OF" |"CO" | "INC" | "BY" |
   "LLC" | "LLP" | "LTD" | "LP" | "L L C" | "L L P" | "L P" | "L LC" | 
   "PARTNER" | "PARTNERS" | "PARTNERSHIP" | "PTNR" |
   "CURRENT" | "OWNER" | "THE" | "LIMITED" | "DBA" | 
   "CORP" | "LTD" | "INCORP" | "UNITED" |
   "AT" | "ENTERPRISE" | "ENTERPRISES" | "ASSOC" | "ASSOCIATION" | 
   "COMMUNITY" | "CITY" | "COUNTY" | "STATE" | "WORLD" | "AMERICA" | "AMERICAN" | 
   "U S" | "US" | "FEDERAL" | "CAPITOL" | "DISTRICT" | "GOVERNMENT" |
   "REAL ESTATE" |
   "FIRST" | "SECOND" | "THIRD"
>}

/* Except for VIRGINIA, GEORGIA, WASHINGTON */
TOKEN : { <US_STATE: "ALABAMA" | "ALASKA" | "ARIZONA" | "ARKANSAS" | "CALIFORNIA" | "COLORADO" | "CONNECTICUT" | "DELAWARE" | "FLORIDA" | "HAWAII" | "IDAHO" | "ILLINOIS" | "INDIANA" | "IOWA" | "KANSAS" | "KENTUCKY" | "LOUISIANA" | "MAINE" | "MARYLAND" | "MASSACHUSETTS" | "MICHIGAN" | "MINNESOTA" | "MISSISSIPPI" | "MISSOURI" | "MONTANA" | "NEBRASKA" | "NEVADA" | "NEW HAMPSHIRE" | "NEW JERSEY" | "NEW MEXICO" | "NEW YORK" | "NORTH CAROLINA" | "NORTH DAKOTA" | "OHIO" | "OKLAHOMA" | "OREGON" | "PENNSYLVANIA" | "RHODE ISLAND" | "SOUTH CAROLINA" | "SOUTH DAKOTA" | "TENNESSEE" | "TEXAS" | "UTAH" | "VERMONT" | "WEST VIRGINIA" | "WISCONSIN" | "WYOMING" >} 

/* State abbreviations, except for AL, CA, CO, DE, IL, IN, LA, GA, MA, MI, MO, OH, OR, WI, PA, UT, OK, KY */
TOKEN : { <US_STATE_ABBV:  "AK" | "AZ" | "AR" | "CT" | "FL" | "HI" | "ID" | "IA" | "KS" | "ME" | "MD" | "MN" | "MS" | "MT" | "NE" | "NV" | "NH" | "NJ" | "NM" | "NY" | "NC" | "ND" | "RI" | "SC" | "SD" | "TN" | "TX" | "VT" | "VA" | "WA" | "WV" | "WY" >}

/* This is the catch-all token */
TOKEN : { <_TOKEN: (~[" ", "\t", "\n", "\r", ".", ",", "0"-"9"])+ > }
