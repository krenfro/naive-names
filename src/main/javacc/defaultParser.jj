options {
   IGNORE_CASE = true;
   STATIC = false;
   SUPPORT_CLASS_VISIBILITY_PUBLIC = false;
}


PARSER_BEGIN(DefaultMultiNameParser)
package com.github.krenfro.names;
import java.util.*;
import java.io.*;
import java.util.logging.Logger;
import java.util.logging.Level;

/**
 * This class is generated by javacc.  
 * To make changes, see src/main/javacc/parser.jj
 */
final class DefaultMultiNameParser implements MultiNameParser{

    private static final Logger logger = Logger.getLogger(DefaultMultiNameParser.class.getName());

    private NameParsingContext ctx;
    
    public DefaultMultiNameParser(NameParsingContext ctx) {
        this((Reader) new StringReader(""));
        this.ctx = ctx;
    }

    public List<Name> parse(String text){
        Objects.requireNonNull(text);
        if (text.isEmpty()){
            throw new IllegalArgumentException("text is empty");
        }
        ctx.reset();
        ctx.setOriginal(text);
        ReInit((Reader)(new StringReader(text)));
        try{
            start();
        }
        catch(ParseException ex){
            logger.log(Level.FINE, "Problem parsing [" + text + "] : " + ex.getMessage());
            ctx.reset();
            ctx.addName(new Name(text));            
        }
        return ctx.getNames();
    }   

    private void handlePunctuation(Token t){
        if (t.specialToken != null && ctx.isPreservePunct()){
            ctx.appendToPreviousToken(t.specialToken.image);
        }
    }
}
PARSER_END(DefaultMultiNameParser)

void start() : {}  { (name() (careOf() name())? ) (trust())? done() }

void done() : {Token t;} {t=<EOF> {
    handlePunctuation(t);
    ctx.done();
}}

void name() : {} { (token() | multiName() | prefix() | suffix() | comma() | company() | estate() | trust() | and() | web() | etux() | alsoKnownAs() )+ {
}}

void company() : {Token t;} { 
    t=<COMPANY> {
        handlePunctuation(t);
        ctx.add(new ParsedToken(t.image, TokenType.COMPANY));
    } | 
    t=<US_STATE> {
        handlePunctuation(t);
        ctx.add(new ParsedToken(t.image, TokenType.COMPANY));
    } | 
    t=<US_STATE_ABBV> {
        handlePunctuation(t);
        ctx.add(new ParsedToken(t.image, TokenType.COMPANY));
    }
}

void web() : {Token t;} { t=<WEB> {
    ctx.appendToPreviousToken(t.image);
}}

void suffix() : {Token t;} { t=<SUFFIX> {
    handlePunctuation(t);
    ctx.add(new ParsedToken(t.image, TokenType.SUFFIX));
}}

void prefix() : {Token t;} { t=<PREFIX> {
    handlePunctuation(t);
    ctx.add(new ParsedToken(t.image, TokenType.PREFIX));
}}

void estate() : {Token t;} { t=<ESTATE> {
    handlePunctuation(t);
    ctx.add(new ParsedToken(t.image, TokenType.ESTATE));
}}

void trust() : {Token t;} { 
    t=<TRUST> {
        handlePunctuation(t);
        ctx.add(new ParsedToken(t.image.trim(), TokenType.TRUST));
    }
/* | 
    t=<SIMPLE_TRUST> {
        handlePunctuation(t);
        ctx.add(new ParsedToken(t.image, TokenType.TRUST));
    }*/
}

void comma() : {Token t;} { t=<COMMA> {
    handlePunctuation(t);
    ctx.comma();
}}

void and() : {Token t;} { t=<AND>  {
    handlePunctuation(t);
    if (ctx.isFoundCareOf()){
        ctx.add(new ParsedToken(t.image, TokenType.COMPANY));
    }
    else{
        ctx.and(t.image);
    }
}}

void careOf() : {Token t;} { t=<CARE_OF>  {
    handlePunctuation(t);
    ctx.pushName();
    ctx.careOf();
    ctx.setLastNameFirst(false);
    String s = t.image;
    if (s.startsWith("%") && s.length() > 1){
        s = s.substring(1);
        if (s.equals(ctx.getPreviousLastName())){
            ctx.add(new ParsedToken(s, TokenType.LAST));
        }
        else{
            ctx.add(new ParsedToken(s, TokenType.UNKNOWN));
        }
    }
}}


void alsoKnownAs() : {Token t;} { t=<AKA> {
    handlePunctuation(t);     
    ctx.done();
}}

void etux() : {Token t;} { t=<ETUX> {
    handlePunctuation(t);
    ctx.done();
}}

void multiName() : {Token t;} { t=<MULTI_NAME> {
    handlePunctuation(t);
    ctx.add(new ParsedToken(t.image, TokenType.LAST));
}}

void token() : {Token t;} { t=<_TOKEN> {
    handlePunctuation(t);
    if (CompanyNameTokens.contains(t.image)){
        ctx.add(new ParsedToken(t.image, TokenType.COMPANY));
    }
    else if (t.image.equals(ctx.getPreviousLastName())){
        ctx.add(new ParsedToken(t.image, TokenType.LAST));
    }   
    else{
        ctx.add(new ParsedToken(t.image, TokenType.UNKNOWN));
    }
}}



SPECIAL_TOKEN :
{
  <PUNCT: ["."]>
}

SKIP : { <DELIMITERS: [" ","\t","\n","\r"]> }
SKIP : { <TRUSTEE : "EXECUTOR" | ("CO" (["-"," "]))? "TRUSTE" ("E")? (" OF")?> }
TOKEN : { <ETUX : "ET" (" ")? ( "UX" | "UC" | "AL" | "VIR" | "TU" | "TIV" )> }


/*TOKEN : { <TRUST : (("LIV" | "LVG" | "REV" | "IRR" | "RES" | "FAM" | "MAR" | "CO" | "SUC")(["A"-"Z"])*)+(" TR")("UST"|"ST"|"US")> }*/
TOKEN : { <TRUST : (
    ("L" | "R" | "LIV" | "LIVING" | "RES" | "RESIDUARY" | 
     "CHILDRENS" | "SUC" | "SUCC" | "REV" | "REVOCABLE" | 
     "IRR" | "IRREV" | "IRREVOCABLE" | 
     "FAM" | "FAMILY" | "MARITAL")([" ","/"]))*
     ("TR" | "TRS" | "TRUST" | "TRST" | "TRUS")> }


TOKEN : { <ESTATE: ("LIFE ")?"EST" ("ATE")? (" OF")?> }
TOKEN : { <COMMA: "," > }
TOKEN : { <AND: ("AND" | ["+", "&"](["A"-"Z"])*) > }
TOKEN : { <CARE_OF: ("C/O" | "%"(["A"-"Z"])* )> }
TOKEN : { <AKA: ("A"|"F"|"N")("KA") > }
TOKEN : { <WEB: (".COM" | ".NET" | ".EDU") >}
TOKEN : { <PREFIX: "DR" | "MR" | "MRS" | "MS" | "MISS" | "REV" | "HON" | "PROF" | "ATTY" | "PRES" | "GOV" | "COACH" | "OFC" | "GEN" | "COL" | "LT" | "CMDR" | "CAPT" | "MAJ" | "ADM" | "SGT" | "PVT" | "SEC" | "AMB" | "SEN" | "SUPT" | "MSGR" > }
TOKEN : { <SUFFIX: "JR" | "SR" | "II" | "III" | "IV" | "ESQ" | "PHD" | "MD" | "DMD" | "PA" > }
TOKEN : { <MULTI_NAME: "VAN" | "DE" | "LA" | "LAS" | "MC" | "MAC" | "EL" | "VON" | "LOS" | "LE" | "DEL" | "DER" > }

/* Single token company names are handled by the CompanyNameTokens class.  
   Some often encountered tokens are duplicated here for speed.  
   Multi-token company name identifiers are handled here. */
TOKEN : { <COMPANY: 
   (["A"-"Z"])*(["/","0"-"9","@"])+(["A"-"Z"])* |  
   (["A"-"Z"])+"'S" |
   "BUSINESS" | "COMPANY" |
   "OF" |"CO" | "INC" | "BY" |
   "LLC" | "LLP" | "LTD" | "LP" | "L L C" | "L L P" | "L P" | "L LC" | 
   "PARTNER" | "PARTNERS" | "PARTNERSHIP" | "PTNR" |
   "CURRENT" | "OWNER" | "THE" | "LIMITED" | "DBA" | 
   "CORP" | "LTD" | "INCORP" | "UNITED" |
   "AT" | "ENTERPRISE" | "ENTERPRISES" | "ASSOC" | "ASSOCIATION" | 
   "COMMUNITY" | "CITY" | "COUNTY" | "STATE" | "WORLD" | "AMERICA" | "AMERICAN" | 
   "U S" | "US" | "FEDERAL" | "CAPITOL" | "DISTRICT" | "GOVERNMENT" |
   "REAL ESTATE" |
   "FIRST" | "SECOND" | "THIRD"
>}

/* Except for VIRGINIA, GEORGIA, WASHINGTON */
TOKEN : { <US_STATE: "ALABAMA" | "ALASKA" | "ARIZONA" | "ARKANSAS" | "CALIFORNIA" | "COLORADO" | "CONNECTICUT" | "DELAWARE" | "FLORIDA" | "HAWAII" | "IDAHO" | "ILLINOIS" | "INDIANA" | "IOWA" | "KANSAS" | "KENTUCKY" | "LOUISIANA" | "MAINE" | "MARYLAND" | "MASSACHUSETTS" | "MICHIGAN" | "MINNESOTA" | "MISSISSIPPI" | "MISSOURI" | "MONTANA" | "NEBRASKA" | "NEVADA" | "NEW HAMPSHIRE" | "NEW JERSEY" | "NEW MEXICO" | "NEW YORK" | "NORTH CAROLINA" | "NORTH DAKOTA" | "OHIO" | "OKLAHOMA" | "OREGON" | "PENNSYLVANIA" | "RHODE ISLAND" | "SOUTH CAROLINA" | "SOUTH DAKOTA" | "TENNESSEE" | "TEXAS" | "UTAH" | "VERMONT" | "WEST VIRGINIA" | "WISCONSIN" | "WYOMING" >} 

/* State abbreviations, except for AL, CA, CO, DE, IL, IN, LA, GA, MA, MI, MO, OH, OR, WI, PA, UT, OK, KY */
TOKEN : { <US_STATE_ABBV:  "AK" | "AZ" | "AR" | "CT" | "FL" | "HI" | "ID" | "IA" | "KS" | "ME" | "MD" | "MN" | "MS" | "MT" | "NE" | "NV" | "NH" | "NJ" | "NM" | "NY" | "NC" | "ND" | "RI" | "SC" | "SD" | "TN" | "TX" | "VT" | "VA" | "WA" | "WV" | "WY" >}

/* This is the catch-all token */
TOKEN : { <_TOKEN: (~[" ", "\t", "\n", "\r", ".", ",", "0"-"9"])+ > }
